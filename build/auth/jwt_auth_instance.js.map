{"version":3,"sources":["../../src/auth/jwt_auth_instance.js"],"names":["jwt","jsonwebtoken","getKey","keyPath","fs","readFileSync","generateToken","payload","privateKey","verifyOptions","algorithm","expiresIn","sign","token","getToken","headers","authorization","includes","parted","split","length","undefined","verifyToken","req","res","next","publicKey","statusCode","message","verify","decodedToken","TokenExpiredError","userId","sub"],"mappings":";;;;;;;;;;;;;AAAA;;AACA;;AACA;;AACA;;AAEA,IAAMA,GAAG,GAAGC,wBAAZ;;AACA,IAAMC,MAAM,GAAG,SAATA,MAAS,CAAAC,OAAO;AAAA,SAAIC,eAAGC,YAAH,CAAgBF,OAAhB,EAAyB,OAAzB,CAAJ;AAAA,CAAtB;;AAEO,IAAMG,aAAa;AAAA,2FAAG,iBAAMC,OAAN;AAAA;AAAA;AAAA;AAAA;AAAA;AACvBC,YAAAA,UADuB,GACVN,MAAM,CAAC,8BAAU,aAAV,CAAD,CADI;AAErBO,YAAAA,aAFqB,GAEL;AACpBC,cAAAA,SAAS,EAAE,OADS;AAEpBC,cAAAA,SAAS,EAAE;AAFS,aAFK;AAAA;AAAA,mBAMPX,GAAG,CAACY,IAAJ,CAASL,OAAT,EAAkBC,UAAlB,EAA8BC,aAA9B,CANO;;AAAA;AAMrBI,YAAAA,KANqB;AAAA,6CAOpBA,KAPoB;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAAH;;AAAA,kBAAbP,aAAa;AAAA;AAAA;AAAA,GAAnB;;;;AAUA,IAAMQ,QAAQ,GAAG,SAAXA,QAAW,CAAAC,OAAO,EAAI;AACjC,MACEA,OAAO,IACPA,OAAO,CAACC,aADR,IAEAD,OAAO,CAACC,aAAR,CAAsBC,QAAtB,CAA+B,QAA/B,CAHF,EAIE;AACA,QAAMC,MAAM,GAAGH,OAAO,CAACC,aAAR,CAAsBG,KAAtB,CAA4B,GAA5B,CAAf;;AACA,QAAID,MAAM,CAACE,MAAP,KAAkB,CAAtB,EAAyB;AACvB,aAAOF,MAAM,CAAC,CAAD,CAAb;AACD;AACF;;AACD,SAAOG,SAAP;AACD,CAZM;;;;AAcA,IAAMC,WAAW;AAAA,4FAAG,kBAAOC,GAAP,EAAYC,GAAZ,EAAiBC,IAAjB;AAAA;AAAA;AAAA;AAAA;AAAA;AACnBC,YAAAA,SADmB,GACPtB,eAAGC,YAAH,CAAgB,8BAAU,YAAV,CAAhB,EAAyC,MAAzC,CADO;AAEnBI,YAAAA,aAFmB,GAEH;AACpBC,cAAAA,SAAS,EAAE;AADS,aAFG;AAMnBG,YAAAA,KANmB,GAMXC,QAAQ,CAACS,GAAG,CAACR,OAAL,CANG;;AAAA,gBAOpBF,KAPoB;AAAA;AAAA;AAAA;;AAAA,8CAQhB,wBAAY;AAAEc,cAAAA,UAAU,EAAE,GAAd;AAAmBC,cAAAA,OAAO,EAAE;AAA5B,aAAZ,CARgB;;AAAA;AAAA;AAAA;AAAA,mBAYF5B,GAAG,CAAC6B,MAAJ,CAAWhB,KAAX,EAAkBa,SAAlB,EAA6BjB,aAA7B,CAZE;;AAAA;AAYvBqB,YAAAA,YAZuB;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA,kBAcnB,wBAAiB9B,GAAG,CAAC+B,iBAdF;AAAA;AAAA;AAAA;;AAAA,8CAed,wBAAY;AAAEJ,cAAAA,UAAU,EAAE,GAAd;AAAmBC,cAAAA,OAAO,EAAE;AAA5B,aAAZ,CAfc;;AAAA;AAAA,8CAiBhB,wBAAY;AAAED,cAAAA,UAAU,EAAE,GAAd;AAAmBC,cAAAA,OAAO,EAAE;AAA5B,aAAZ,CAjBgB;;AAAA;AAmBnBI,YAAAA,MAnBmB,GAmBVF,YAAY,CAACG,GAnBH;AAoBzBV,YAAAA,GAAG,CAACS,MAAJ,GAAaA,MAAb;AACAP,YAAAA,IAAI;;AArBqB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAAH;;AAAA,kBAAXH,WAAW;AAAA;AAAA;AAAA,GAAjB","sourcesContent":["import jsonwebtoken from 'jsonwebtoken'\r\nimport fs from 'fs'\r\nimport { getConfig } from '../config/global_config'\r\nimport { handleError } from '../helpers/error'\r\n\r\nconst jwt = jsonwebtoken\r\nconst getKey = keyPath => fs.readFileSync(keyPath, 'utf-8')\r\n\r\nexport const generateToken = async payload => {\r\n  let privateKey = getKey(getConfig('/privateKey'))\r\n  const verifyOptions = {\r\n    algorithm: 'RS256',\r\n    expiresIn: '24h',\r\n  }\r\n  const token = await jwt.sign(payload, privateKey, verifyOptions)\r\n  return token\r\n}\r\n\r\nexport const getToken = headers => {\r\n  if (\r\n    headers &&\r\n    headers.authorization &&\r\n    headers.authorization.includes('Bearer')\r\n  ) {\r\n    const parted = headers.authorization.split(' ')\r\n    if (parted.length === 2) {\r\n      return parted[1]\r\n    }\r\n  }\r\n  return undefined\r\n}\r\n\r\nexport const verifyToken = async (req, res, next) => {\r\n  const publicKey = fs.readFileSync(getConfig('/publicKey'), 'utf8')\r\n  const verifyOptions = {\r\n    algorithm: 'RS256',\r\n  }\r\n\r\n  const token = getToken(req.headers)\r\n  if (!token) {\r\n    return handleError({ statusCode: 401, message: 'Token is not valid!' })\r\n  }\r\n  let decodedToken\r\n  try {\r\n    decodedToken = await jwt.verify(token, publicKey, verifyOptions)\r\n  } catch (error) {\r\n    if (error instanceof jwt.TokenExpiredError) {\r\n      return handleError({ statusCode: 401, message: 'Access token expired!' })\r\n    }\r\n    return handleError({ statusCode: 401, message: 'Token is not valid!' })\r\n  }\r\n  const userId = decodedToken.sub\r\n  req.userId = userId\r\n  next()\r\n}\r\n"],"file":"jwt_auth_instance.js"}